CCS PCM C Compiler, Version 5.015, 5967               15-nov-25 17:58

               Filename:   C:\Users\Monitor\Desktop\MicroCon\Projetos PCW\semaforo2\semaforo2.lst

               ROM used:   657 words (8%)
                           Largest free fragment is 2048
               RAM used:   16 (4%) at main() level
                           30 (8%) worst case
               Stack used: 3 locations
               Stack size: 8

*
0000:  MOVLW  01
0001:  MOVWF  0A
0002:  GOTO   18B
0003:  NOP
.................... /* 
....................  * ============================================================================== 
....................  * PROJETO: Semáforo de Pedestres Inteligente 
....................  * PLACA ALVO: PICGenios (com PIC16F877A) 
....................  * 
....................  * DESCRIÇÃO: 
....................  * Implementa um semáforo de carros e pedestres com as seguintes regras: 
....................  * 1. Padrão: Carro Verde, Pedestre Vermelho. 
....................  * 2. Ao apertar o botão: 
....................  * a) Se o sinal abriu para carros há menos de 20s, o sistema espera 
....................  * o tempo restante até completar 20s. 
....................  * b) Inicia a sequência de fechamento para carros e abertura para pedestres. 
....................  * 3. O pedestre tem um tempo total de 15s (10s fixo + 5s piscando) 
....................  * para atravessar, com contagem regressiva no display. 
....................  * ============================================================================== 
....................  */ 
....................  
.................... // --- 1. Inclusão de Bibliotecas e Configurações --- 
.................... #include <16F877A.h> // Biblioteca específica do PIC16F877A 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  01
0009:  RETLW  01
000A:  RETLW  01
000B:  RETLW  01
000C:  RETLW  01
000D:  RETLW  01
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  01
0011:  RETLW  01
0012:  RETLW  00
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  01
0017:  RETLW  01
0018:  RETLW  00
0019:  RETLW  01
001A:  RETLW  01
001B:  RETLW  00
001C:  RETLW  01
001D:  RETLW  01
001E:  RETLW  01
001F:  RETLW  01
0020:  RETLW  01
0021:  RETLW  00
0022:  RETLW  00
0023:  RETLW  01
0024:  RETLW  00
0025:  RETLW  01
0026:  RETLW  01
0027:  RETLW  00
0028:  RETLW  00
0029:  RETLW  01
002A:  RETLW  01
002B:  RETLW  01
002C:  RETLW  00
002D:  RETLW  01
002E:  RETLW  01
002F:  RETLW  00
0030:  RETLW  01
0031:  RETLW  01
0032:  RETLW  01
0033:  RETLW  00
0034:  RETLW  01
0035:  RETLW  01
0036:  RETLW  01
0037:  RETLW  01
0038:  RETLW  01
0039:  RETLW  01
003A:  RETLW  01
003B:  RETLW  01
003C:  RETLW  00
003D:  RETLW  00
003E:  RETLW  00
003F:  RETLW  00
0040:  RETLW  01
0041:  RETLW  01
0042:  RETLW  01
0043:  RETLW  01
0044:  RETLW  01
0045:  RETLW  01
0046:  RETLW  01
0047:  RETLW  01
0048:  RETLW  01
0049:  RETLW  01
004A:  RETLW  01
004B:  RETLW  00
004C:  RETLW  01
004D:  RETLW  01
004E:  MOVF   36,W
004F:  ANDLW  07
0050:  MOVWF  77
0051:  RRF    36,W
0052:  MOVWF  78
0053:  RRF    78,F
0054:  RRF    78,F
0055:  MOVLW  1F
0056:  ANDWF  78,F
0057:  MOVF   78,W
0058:  ADDWF  38,W
0059:  MOVWF  04
005A:  BCF    03.7
005B:  BTFSC  39.0
005C:  BSF    03.7
005D:  CLRF   78
005E:  INCF   78,F
005F:  INCF   77,F
0060:  GOTO   062
0061:  RLF    78,F
0062:  DECFSZ 77,F
0063:  GOTO   061
0064:  MOVF   37,F
0065:  BTFSC  03.2
0066:  GOTO   06A
0067:  MOVF   78,W
0068:  IORWF  00,F
0069:  GOTO   06D
006A:  COMF   78,F
006B:  MOVF   78,W
006C:  ANDWF  00,F
006D:  RETURN
*
00DA:  MOVF   33,W
00DB:  CLRF   78
00DC:  SUBWF  32,W
00DD:  BTFSC  03.0
00DE:  GOTO   0E2
00DF:  MOVF   32,W
00E0:  MOVWF  77
00E1:  GOTO   0EE
00E2:  CLRF   77
00E3:  MOVLW  08
00E4:  MOVWF  34
00E5:  RLF    32,F
00E6:  RLF    77,F
00E7:  MOVF   33,W
00E8:  SUBWF  77,W
00E9:  BTFSC  03.0
00EA:  MOVWF  77
00EB:  RLF    78,F
00EC:  DECFSZ 34,F
00ED:  GOTO   0E5
00EE:  RETURN
*
00FB:  CLRF   77
00FC:  CLRF   78
00FD:  MOVF   36,W
00FE:  BCF    03.0
00FF:  BTFSC  37.0
0100:  ADDWF  77,F
0101:  RRF    77,F
0102:  RRF    78,F
0103:  BTFSC  37.1
0104:  ADDWF  77,F
0105:  RRF    77,F
0106:  RRF    78,F
0107:  BTFSC  37.2
0108:  ADDWF  77,F
0109:  RRF    77,F
010A:  RRF    78,F
010B:  BTFSC  37.3
010C:  ADDWF  77,F
010D:  RRF    77,F
010E:  RRF    78,F
010F:  BTFSC  37.4
0110:  ADDWF  77,F
0111:  RRF    77,F
0112:  RRF    78,F
0113:  BTFSC  37.5
0114:  ADDWF  77,F
0115:  RRF    77,F
0116:  RRF    78,F
0117:  BTFSC  37.6
0118:  ADDWF  77,F
0119:  RRF    77,F
011A:  RRF    78,F
011B:  BTFSC  37.7
011C:  ADDWF  77,F
011D:  RRF    77,F
011E:  RRF    78,F
....................  
.................... #list 
....................  
....................  
.................... // --- 2. Configuração dos FUSES --- 
.................... // Define as "configurações de hardware" do microcontrolador 
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP 
.................... // XT: Cristal externo de 4MHz (XT = Cristal, 4-20MHz) 
.................... // NOWDT: Desabilita o Watchdog Timer (Cão de Guarda) 
.................... // NOPROTECT: Permite a leitura do código gravado (desprotegido) 
.................... // NOLVP: Desabilita a programação em baixa tensão (libera o pino RB3) 
....................  
.................... #use delay(clock=4000000) // Informa ao compilador que o clock é de 4MHz. 
*
00A7:  MOVLW  35
00A8:  MOVWF  04
00A9:  BCF    03.7
00AA:  MOVF   00,W
00AB:  BTFSC  03.2
00AC:  GOTO   0BB
00AD:  MOVLW  01
00AE:  MOVWF  78
00AF:  CLRF   77
00B0:  DECFSZ 77,F
00B1:  GOTO   0B0
00B2:  DECFSZ 78,F
00B3:  GOTO   0AF
00B4:  MOVLW  4A
00B5:  MOVWF  77
00B6:  DECFSZ 77,F
00B7:  GOTO   0B6
00B8:  GOTO   0B9
00B9:  DECFSZ 00,F
00BA:  GOTO   0AD
00BB:  RETURN
....................                          // Essencial para o delay_ms() funcionar corretamente. 
....................  
.................... // ---------- 3. Mapeamento de Pinos (Hardware) ---------- 
.................... // Define "apelidos" para os pinos, facilitando a leitura do código. 
....................  
.................... // LEDs do semáforo de carros (conectados ao PORTB) 
.................... #define CARRO_VERMELHO  PIN_B1 
.................... #define CARRO_AMARELO   PIN_B2 
.................... #define CARRO_VERDE     PIN_B3 
....................  
.................... // LEDs do semáforo de pedestres (conectados ao PORTB) 
.................... #define PED_VERMELHO    PIN_B5 
.................... #define PED_VERDE       PIN_B6 
....................  
.................... // Botão de entrada (conectado ao PORTB) 
.................... #define BOTAO           PIN_B0  // O botão do pedestre é ativo em nível 0 (pressionado) 
....................  
.................... // Mapeamento dos Displays de 7 Segmentos 
.................... // Pinos de controle (seleção de qual display acende) 
.................... #define DISP_DEZENA     PIN_A4 // Pino que liga o display da DEZENA 
.................... #define DISP_UNIDADE    PIN_A5 // Pino que liga o display da UNIDADE 
....................  
.................... // Pinos de dados (segmentos a-g e "habilitador") 
.................... #define SEGMENT_ENABLE  PIN_D7 // Habilitador geral dos segmentos no PORTD 
....................  
.................... // ---------- 4. Tabela de Segmentos (Ânodo Comum) ---------- 
.................... // Este é o "mapa" que traduz um número (0-9) em quais segmentos (a-g) 
.................... // devem ser ligados. O '1' significa "acende o segmento". 
.................... // A ordem é {a, b, c, d, e, f, g} - correspondendo a PIN_D0 até PIN_D6 
.................... const int8 segmentos[10][7] = { 
....................     {1,1,1,1,1,1,0}, // 0 
....................     {0,1,1,0,0,0,0}, // 1 
....................     {1,1,0,1,1,0,1}, // 2 
....................     {1,1,1,1,0,0,1}, // 3 
....................     {0,1,1,0,0,1,1}, // 4 
....................     {1,0,1,1,0,1,1}, // 5 
....................     {1,0,1,1,1,1,1}, // 6 
....................     {1,1,1,0,0,0,0}, // 7 
....................     {1,1,1,1,1,1,1}, // 8 
....................     {1,1,1,1,0,1,1}  // 9 
.................... }; 
....................  
.................... // ---------- 5. Funções Auxiliares (Modularização) ---------- 
....................  
.................... /* 
....................  * Função: display_off 
....................  * Desliga completamente todos os displays e segmentos. 
....................  * Útil para economizar energia e garantir que nada fique aceso 
....................  * quando não deveria. 
....................  */ 
.................... void display_off() { 
....................     // Coloca todos os 7 pinos de segmento (RD0-RD6) em 0 
....................     for (int i = 0; i < 7; i++) { 
*
006E:  CLRF   32
006F:  MOVF   32,W
0070:  SUBLW  06
0071:  BTFSS  03.0
0072:  GOTO   084
....................        output_bit(PIN_D0 + i, 0); 
0073:  MOVLW  40
0074:  ADDWF  32,W
0075:  MOVWF  33
0076:  MOVWF  36
0077:  CLRF   37
0078:  CLRF   39
0079:  CLRF   38
007A:  CALL   04E
007B:  MOVF   33,W
007C:  MOVWF  36
007D:  CLRF   37
007E:  CLRF   39
007F:  MOVLW  80
0080:  MOVWF  38
0081:  CALL   04E
0082:  INCF   32,F
0083:  GOTO   06F
....................     } 
....................     // Desliga o habilitador geral (RD7) 
....................     output_low(SEGMENT_ENABLE); 
0084:  BSF    03.5
0085:  BCF    08.7
0086:  BCF    03.5
0087:  BCF    08.7
....................     // Desliga os pinos de controle dos displays (RA4, RA5) 
....................     output_low(DISP_DEZENA); 
0088:  BSF    03.5
0089:  BCF    05.4
008A:  BCF    03.5
008B:  BCF    05.4
....................     output_low(DISP_UNIDADE); 
008C:  BSF    03.5
008D:  BCF    05.5
008E:  BCF    03.5
008F:  BCF    05.5
0090:  RETURN
.................... } 
....................  
.................... /* 
....................  * Função: mostra_digito 
....................  * É o núcleo da multiplexação. Acende UM dígito (dezena OU unidade) 
....................  * com um 'valor' específico por um curto período de 5ms. 
....................  */ 
.................... void mostra_digito(int8 valor, int1 dezena) { 
....................     // 1. Envia o padrão do 'valor' (ex: "5") para os pinos RD0-RD6 
....................     for (int i = 0; i < 7; i++) { 
*
00EF:  CLRF   34
00F0:  MOVF   34,W
00F1:  SUBLW  06
00F2:  BTFSS  03.0
00F3:  GOTO   13A
....................        output_bit(PIN_D0 + i, segmentos[valor][i]); 
00F4:  MOVLW  40
00F5:  ADDWF  34,W
00F6:  MOVWF  35
00F7:  MOVF   32,W
00F8:  MOVWF  36
00F9:  MOVLW  07
00FA:  MOVWF  37
*
011F:  MOVF   34,W
0120:  ADDWF  78,W
0121:  CALL   004
0122:  MOVWF  78
0123:  MOVF   78,F
0124:  BTFSS  03.2
0125:  GOTO   128
0126:  MOVLW  00
0127:  GOTO   129
0128:  MOVLW  01
0129:  MOVWF  77
012A:  MOVF   35,W
012B:  MOVWF  36
012C:  MOVF   77,W
012D:  MOVWF  37
012E:  CLRF   39
012F:  CLRF   38
0130:  CALL   04E
0131:  MOVF   35,W
0132:  MOVWF  36
0133:  CLRF   37
0134:  CLRF   39
0135:  MOVLW  80
0136:  MOVWF  38
0137:  CALL   04E
0138:  INCF   34,F
0139:  GOTO   0F0
....................     } 
....................     // 2. Liga o habilitador geral (RD7) para energizar os segmentos 
....................     output_high(SEGMENT_ENABLE); 
013A:  BSF    03.5
013B:  BCF    08.7
013C:  BCF    03.5
013D:  BSF    08.7
....................  
....................     // 3. Liga o display específico (dezena OU unidade) 
....................     if (dezena) { // Se o parâmetro 'dezena' for VERDADEIRO 
013E:  MOVF   33,F
013F:  BTFSC  03.2
0140:  GOTO   14D
....................        output_high(DISP_DEZENA); // Liga o display da dezena (RA4) 
0141:  BSF    03.5
0142:  BCF    05.4
0143:  BCF    03.5
0144:  BSF    05.4
....................        delay_ms(5);              // Espera 5ms (o olho humano não percebe) 
0145:  MOVLW  05
0146:  MOVWF  35
0147:  CALL   0A7
....................        output_low(DISP_DEZENA);  // Apaga o display da dezena 
0148:  BSF    03.5
0149:  BCF    05.4
014A:  BCF    03.5
014B:  BCF    05.4
....................     } else { // Se for FALSO (é a unidade) 
014C:  GOTO   158
....................        output_high(DISP_UNIDADE); // Liga o display da unidade (RA5) 
014D:  BSF    03.5
014E:  BCF    05.5
014F:  BCF    03.5
0150:  BSF    05.5
....................        delay_ms(5);               // Espera 5ms 
0151:  MOVLW  05
0152:  MOVWF  35
0153:  CALL   0A7
....................        output_low(DISP_UNIDADE);  // Apaga o display da unidade 
0154:  BSF    03.5
0155:  BCF    05.5
0156:  BCF    03.5
0157:  BCF    05.5
....................     } 
....................  
....................     // 4. Desliga o habilitador geral (RD7) para evitar "ghosting" 
....................     output_low(SEGMENT_ENABLE); 
0158:  BSF    03.5
0159:  BCF    08.7
015A:  BCF    03.5
015B:  BCF    08.7
015C:  RETURN
.................... } 
....................  
.................... /* 
....................  * Função: mostra_display 
....................  * Exibe um número de dois dígitos ('valor') por um 'tempo_ms' determinado. 
....................  * Ela fica chamando 'mostra_digito' repetidamente para criar a 
....................  * ilusão de que os dois displays estão acesos ao mesmo tempo. 
....................  */ 
.................... void mostra_display(int8 valor, unsigned int16 tempo_ms) { 
015D:  MOVF   2B,W
015E:  MOVWF  32
015F:  MOVLW  0A
0160:  MOVWF  33
0161:  CALL   0DA
0162:  MOVF   78,W
0163:  MOVWF  2E
0164:  MOVF   2B,W
0165:  MOVWF  32
0166:  MOVLW  0A
0167:  MOVWF  33
0168:  CALL   0DA
0169:  MOVF   77,W
016A:  MOVWF  2F
016B:  CLRF   31
016C:  CLRF   30
....................     int8 dez = valor / 10; // Pega o dígito da dezena (ex: 15 / 10 = 1) 
....................     int8 uni = valor % 10; // Pega o dígito da unidade (ex: 15 % 10 = 5) 
....................     unsigned int16 t = 0;  // Variável para controlar o tempo total 
....................  
....................     // Loop de multiplexação. Roda até que o 'tempo_ms' tenha se passado. 
....................     while (t < tempo_ms) { 
016D:  MOVF   31,W
016E:  SUBWF  2D,W
016F:  BTFSS  03.0
0170:  GOTO   189
0171:  BTFSS  03.2
0172:  GOTO   177
0173:  MOVF   2C,W
0174:  SUBWF  30,W
0175:  BTFSC  03.0
0176:  GOTO   189
....................        mostra_digito(dez, TRUE);  // Mostra a dezena por 5ms 
0177:  MOVF   2E,W
0178:  MOVWF  32
0179:  MOVLW  01
017A:  MOVWF  33
017B:  CALL   0EF
....................        t += 5;                    // Adiciona 5ms ao tempo total 
017C:  MOVLW  05
017D:  ADDWF  30,F
017E:  BTFSC  03.0
017F:  INCF   31,F
....................        mostra_digito(uni, FALSE); // Mostra a unidade por 5ms 
0180:  MOVF   2F,W
0181:  MOVWF  32
0182:  CLRF   33
0183:  CALL   0EF
....................        t += 5;                    // Adiciona 5ms ao tempo total 
0184:  MOVLW  05
0185:  ADDWF  30,F
0186:  BTFSC  03.0
0187:  INCF   31,F
0188:  GOTO   16D
....................     } 
....................      
....................     // Garante que o display apague ao final do tempo 
....................     display_off();  
0189:  CALL   06E
018A:  RETURN
.................... } 
....................  
.................... /* 
....................  * Função: botao_pressionado 
....................  * Verifica se o botão foi pressionado. Inclui duas técnicas importantes: 
....................  * 1. Debounce: Evita que ruídos elétricos sejam contados como múltiplos cliques. 
....................  * 2. Wait-for-release: Espera o usuário soltar o botão antes de retornar 
....................  * VERDADEIRO. Isso evita que o programa execute o ciclo várias vezes 
....................  * se o usuário segurar o botão. 
....................  */ 
.................... int1 botao_pressionado() { 
....................     if (!input(BOTAO)) { // 1. Verifica se o botão está pressionado (nível 0) 
*
00BC:  BSF    03.5
00BD:  BSF    06.0
00BE:  BCF    03.5
00BF:  BTFSC  06.0
00C0:  GOTO   0D5
....................        delay_ms(20); // 2. Espera 20ms (filtro de "debounce") 
00C1:  MOVLW  14
00C2:  MOVWF  35
00C3:  CALL   0A7
....................        if (!input(BOTAO)) { // 3. Verifica NOVAMENTE se ainda está pressionado 
00C4:  BSF    03.5
00C5:  BSF    06.0
00C6:  BCF    03.5
00C7:  BTFSC  06.0
00C8:  GOTO   0D5
....................            
....................           // 4. (Wait-for-release) Fica "preso" aqui enquanto o botão 
....................           //    estiver sendo segurado. 
....................           while (!input(BOTAO)) { delay_ms(10); }  
00C9:  BSF    03.5
00CA:  BSF    06.0
00CB:  BCF    03.5
00CC:  BTFSC  06.0
00CD:  GOTO   0D2
00CE:  MOVLW  0A
00CF:  MOVWF  35
00D0:  CALL   0A7
00D1:  GOTO   0C9
....................            
....................           // 5. Só retorna VERDADEIRO depois que o usuário soltar o botão. 
....................           return TRUE; 
00D2:  MOVLW  01
00D3:  MOVWF  78
00D4:  GOTO   0D7
....................        } 
....................     } 
....................     // Se não passou nas verificações, retorna FALSO. 
....................     return FALSE; 
00D5:  MOVLW  00
00D6:  MOVWF  78
00D7:  BCF    0A.3
00D8:  BCF    0A.4
00D9:  GOTO   1AC (RETURN)
.................... } 
....................  
.................... /* 
....................  * Função: estado_padrao 
....................  * Configura os LEDs para o estado inicial e mais comum do semáforo: 
....................  * Carro com sinal verde, Pedestre com sinal vermelho, Display apagado. 
....................  */ 
.................... void estado_padrao() { 
....................     output_low(CARRO_VERMELHO); 
*
0091:  BSF    03.5
0092:  BCF    06.1
0093:  BCF    03.5
0094:  BCF    06.1
....................     output_low(CARRO_AMARELO); 
0095:  BSF    03.5
0096:  BCF    06.2
0097:  BCF    03.5
0098:  BCF    06.2
....................     output_high(CARRO_VERDE); 
0099:  BSF    03.5
009A:  BCF    06.3
009B:  BCF    03.5
009C:  BSF    06.3
....................  
....................     output_high(PED_VERMELHO); 
009D:  BSF    03.5
009E:  BCF    06.5
009F:  BCF    03.5
00A0:  BSF    06.5
....................     output_low(PED_VERDE); 
00A1:  BSF    03.5
00A2:  BCF    06.6
00A3:  BCF    03.5
00A4:  BCF    06.6
....................  
....................     display_off(); 
00A5:  CALL   06E
00A6:  RETURN
.................... } 
....................  
.................... // ---------- 6. Programa Principal (main) ---------- 
....................  
.................... void main() { 
*
018B:  MOVF   03,W
018C:  ANDLW  1F
018D:  MOVWF  03
018E:  BSF    03.5
018F:  BSF    1F.0
0190:  BSF    1F.1
0191:  BSF    1F.2
0192:  BCF    1F.3
0193:  MOVLW  07
0194:  MOVWF  1C
0195:  BCF    03.7
0196:  MOVLW  4E
0197:  BCF    03.5
0198:  MOVWF  22
0199:  MOVLW  20
019A:  MOVWF  21
019B:  CLRF   24
019C:  CLRF   23
....................     // --- Variáveis de Controle de Tempo --- 
....................     // Usamos 'unsigned long' (32 bits) para evitar que o contador "vire" (estouro). 
....................     // O 'UL' no final força o número a ser tratado como unsigned long. 
....................     unsigned long tempo = 20000UL;  // "Relógio" mestre do sistema, em ms. 
....................                                     // Começa em 20000 para permitir o acionamento imediato. 
....................     unsigned long ultimo = 0UL;     // "Timestamp" de quando o botão foi pressionado pela última vez. 
....................     unsigned long decorrido, wait;  // Variáveis auxiliares para o cálculo de espera. 
....................     unsigned int bloco;             // Auxiliar para o loop de espera 
....................     int8 i;                         // Contador para os loops 'for' do display 
....................  
....................     // --- Configuração Inicial (Setup) --- 
....................     setup_adc(ADC_OFF);           // Desliga o conversor Analógico-Digital 
019D:  BCF    1F.0
....................     setup_adc_ports(NO_ANALOGS);  // Define todos os pinos como digitais 
019E:  BSF    03.5
019F:  BSF    1F.0
01A0:  BSF    1F.1
01A1:  BSF    1F.2
01A2:  BCF    1F.3
....................      
....................     // Configura a direção dos pinos 
....................     set_tris_b(0b00000001); // PORTB: Apenas RB0 (BOTAO) é ENTRADA, 
01A3:  MOVLW  01
01A4:  MOVWF  06
....................                             // o resto (LEDs) é SAÍDA. 
....................     port_b_pullups(TRUE);   // Ativa os resistores de pull-up internos do PORTB 
01A5:  BCF    01.7
....................                             // (Garante que RB0 fique em nível 1 quando o botão está solto) 
....................                              
....................     set_tris_d(0x00);       // PORTD (Segmentos) é todo SAÍDA 
01A6:  MOVLW  00
01A7:  MOVWF  08
....................     set_tris_a(0x00);       // PORTA (Controle dos Displays) é todo SAÍDA 
01A8:  MOVWF  05
....................  
....................     // Inicia o semáforo no estado padrão 
....................     estado_padrao(); 
01A9:  BCF    03.5
01AA:  CALL   091
....................  
....................     // --- Loop Infinito --- 
....................     while (TRUE) { 
....................         
....................        // 1. VERIFICA SE O BOTÃO FOI PRESSIONADO 
....................        if (botao_pressionado()) { 
01AB:  GOTO   0BC
01AC:  MOVF   78,F
01AD:  BTFSC  03.2
01AE:  GOTO   288
....................           // Se foi, inicia a lógica de 20 segundos 
....................  
....................           // 2. CALCULA O TEMPO DECORRIDO 
....................           // Calcula quanto tempo (em ms) se passou desde a última vez 
....................           // que o ciclo de pedestre foi iniciado. 
....................           decorrido = (tempo >= ultimo) ? tempo - ultimo : 0UL; 
01AF:  MOVF   24,W
01B0:  SUBWF  22,W
01B1:  BTFSS  03.0
01B2:  GOTO   1C4
01B3:  BTFSS  03.2
01B4:  GOTO   1B9
01B5:  MOVF   23,W
01B6:  SUBWF  21,W
01B7:  BTFSS  03.0
01B8:  GOTO   1C4
01B9:  MOVF   23,W
01BA:  SUBWF  21,W
01BB:  MOVWF  77
01BC:  MOVF   22,W
01BD:  MOVWF  7A
01BE:  MOVF   24,W
01BF:  BTFSS  03.0
01C0:  INCFSZ 24,W
01C1:  SUBWF  7A,F
01C2:  MOVF   77,W
01C3:  GOTO   1C6
01C4:  CLRF   7A
01C5:  MOVLW  00
01C6:  MOVWF  25
01C7:  MOVF   7A,W
01C8:  MOVWF  26
....................  
....................           // 3. VERIFICA A REGRA DOS 20 SEGUNDOS 
....................           if (decorrido < 20000UL) { // Se menos de 20s se passaram 
01C9:  MOVF   26,W
01CA:  SUBLW  4E
01CB:  BTFSS  03.0
01CC:  GOTO   1FD
01CD:  BTFSS  03.2
01CE:  GOTO   1D3
01CF:  MOVF   25,W
01D0:  SUBLW  1F
01D1:  BTFSS  03.0
01D2:  GOTO   1FD
....................              // Calcula quanto tempo FALTA para completar os 20s 
....................              wait = 20000UL - decorrido; 
01D3:  MOVF   25,W
01D4:  SUBLW  20
01D5:  MOVWF  27
01D6:  MOVLW  4E
01D7:  MOVWF  28
01D8:  MOVF   26,W
01D9:  BTFSS  03.0
01DA:  INCFSZ 26,W
01DB:  SUBWF  28,F
....................               
....................              // Fica "preso" aqui, esperando o tempo que falta. 
....................              // O 'bloco' é para o delay_ms não travar se o 'wait' for muito grande. 
....................              while (wait) { 
01DC:  MOVF   27,W
01DD:  IORWF  28,W
01DE:  BTFSC  03.2
01DF:  GOTO   1FD
....................                 bloco = (wait >= 1000UL) ? 1000 : (unsigned int)wait; 
01E0:  MOVF   28,W
01E1:  SUBLW  02
01E2:  BTFSC  03.0
01E3:  GOTO   1ED
01E4:  XORLW  FF
01E5:  BTFSS  03.2
01E6:  GOTO   1EB
01E7:  MOVF   27,W
01E8:  SUBLW  E7
01E9:  BTFSC  03.0
01EA:  GOTO   1ED
01EB:  MOVLW  E8
01EC:  GOTO   1EE
01ED:  MOVF   27,W
01EE:  MOVWF  29
....................                 delay_ms(bloco); // Espera no máximo 1 segundo de cada vez 
01EF:  MOVF   29,W
01F0:  MOVWF  35
01F1:  CALL   0A7
....................                 tempo += bloco;  // Atualiza o relógio mestre 
01F2:  MOVF   29,W
01F3:  ADDWF  21,F
01F4:  BTFSC  03.0
01F5:  INCF   22,F
....................                 wait -= bloco;   // Diminui o tempo restante 
01F6:  MOVF   29,W
01F7:  SUBWF  27,F
01F8:  MOVLW  00
01F9:  BTFSS  03.0
01FA:  MOVLW  01
01FB:  SUBWF  28,F
01FC:  GOTO   1DC
....................              } 
....................           } 
....................  
....................           // 4. ATUALIZA O "TIMESTAMP" 
....................           // Marca o 'agora' como o "último acionamento" 
....................           ultimo = tempo; 
01FD:  MOVF   22,W
01FE:  MOVWF  24
01FF:  MOVF   21,W
0200:  MOVWF  23
....................  
....................           // ========================================================== 
....................           // --- INÍCIO DA SEQUÊNCIA DE TRAVESSIA DE PEDESTRES --- 
....................           // ========================================================== 
....................  
....................           // 5) Carro Amarelo (3 segundos) 
....................           output_low(CARRO_VERDE); 
0201:  BSF    03.5
0202:  BCF    06.3
0203:  BCF    03.5
0204:  BCF    06.3
....................           output_high(CARRO_AMARELO); 
0205:  BSF    03.5
0206:  BCF    06.2
0207:  BCF    03.5
0208:  BSF    06.2
....................           delay_ms(3000); 
0209:  MOVLW  0C
020A:  MOVWF  2B
020B:  MOVLW  FA
020C:  MOVWF  35
020D:  CALL   0A7
020E:  DECFSZ 2B,F
020F:  GOTO   20B
....................           tempo += 3000; // Atualiza o relógio mestre 
0210:  MOVLW  B8
0211:  ADDWF  21,F
0212:  MOVLW  0B
0213:  BTFSC  03.0
0214:  MOVLW  0C
0215:  ADDWF  22,F
....................           output_low(CARRO_AMARELO); 
0216:  BSF    03.5
0217:  BCF    06.2
0218:  BCF    03.5
0219:  BCF    06.2
....................  
....................           // 6) Carro Vermelho (2 segundos de segurança) 
....................           output_high(CARRO_VERMELHO); 
021A:  BSF    03.5
021B:  BCF    06.1
021C:  BCF    03.5
021D:  BSF    06.1
....................           delay_ms(2000); 
021E:  MOVLW  08
021F:  MOVWF  2B
0220:  MOVLW  FA
0221:  MOVWF  35
0222:  CALL   0A7
0223:  DECFSZ 2B,F
0224:  GOTO   220
....................           tempo += 2000; 
0225:  MOVLW  D0
0226:  ADDWF  21,F
0227:  MOVLW  07
0228:  BTFSC  03.0
0229:  MOVLW  08
022A:  ADDWF  22,F
....................  
....................           // 7) Pedestre Verde (10 segundos) - Contagem de 15 a 6 
....................           output_low(PED_VERMELHO); 
022B:  BSF    03.5
022C:  BCF    06.5
022D:  BCF    03.5
022E:  BCF    06.5
....................           output_high(PED_VERDE); 
022F:  BSF    03.5
0230:  BCF    06.6
0231:  BCF    03.5
0232:  BSF    06.6
....................           // Loop de contagem regressiva 
....................           for (i = 15; i >= 6; i--) { 
0233:  MOVLW  0F
0234:  MOVWF  2A
0235:  MOVF   2A,W
0236:  SUBLW  05
0237:  BTFSC  03.0
0238:  GOTO   248
....................              // Mostra o número 'i' no display por 1 segundo 
....................              mostra_display(i, 1000);  
0239:  MOVF   2A,W
023A:  MOVWF  2B
023B:  MOVLW  03
023C:  MOVWF  2D
023D:  MOVLW  E8
023E:  MOVWF  2C
023F:  CALL   15D
....................              tempo += 1000; // Atualiza o relógio mestre 
0240:  MOVLW  E8
0241:  ADDWF  21,F
0242:  MOVLW  03
0243:  BTFSC  03.0
0244:  MOVLW  04
0245:  ADDWF  22,F
0246:  DECF   2A,F
0247:  GOTO   235
....................           } 
....................  
....................           // 8) Pedestre Verde PISCANDO (6 segundos) - Contagem de 5 a 0 
....................           // O loop `for (i = 5; i != 255; i--)` é uma forma de fazer 
....................           // `i >= 0`. Quando 'i' é 0 e subtrai 1, ele "vira" 255 (estouro) 
....................           // e o loop para. 
....................           for (i = 5; i != 255; i--) { 
0248:  MOVLW  05
0249:  MOVWF  2A
024A:  INCFSZ 2A,W
024B:  GOTO   24D
024C:  GOTO   269
....................              // Mostra o número por 0.5 segundos 
....................              mostra_display(i, 500); 
024D:  MOVF   2A,W
024E:  MOVWF  2B
024F:  MOVLW  01
0250:  MOVWF  2D
0251:  MOVLW  F4
0252:  MOVWF  2C
0253:  CALL   15D
....................              tempo += 500; 
0254:  MOVLW  F4
0255:  ADDWF  21,F
0256:  MOVLW  01
0257:  BTFSC  03.0
0258:  MOVLW  02
0259:  ADDWF  22,F
....................              // Apaga o display (display_off é chamado dentro de mostra_display) 
....................              delay_ms(500); // Fica apagado por 0.5 segundos (criando o "pisca") 
025A:  MOVLW  02
025B:  MOVWF  2B
025C:  MOVLW  FA
025D:  MOVWF  35
025E:  CALL   0A7
025F:  DECFSZ 2B,F
0260:  GOTO   25C
....................              tempo += 500; 
0261:  MOVLW  F4
0262:  ADDWF  21,F
0263:  MOVLW  01
0264:  BTFSC  03.0
0265:  MOVLW  02
0266:  ADDWF  22,F
0267:  DECF   2A,F
0268:  GOTO   24A
....................           } 
....................  
....................           // 9) Fim da travessia: Pedestre volta ao Vermelho 
....................           output_low(PED_VERDE); 
0269:  BSF    03.5
026A:  BCF    06.6
026B:  BCF    03.5
026C:  BCF    06.6
....................           output_high(PED_VERMELHO); 
026D:  BSF    03.5
026E:  BCF    06.5
026F:  BCF    03.5
0270:  BSF    06.5
....................           display_off(); // Garante que o display apagou 
0271:  CALL   06E
....................  
....................           // 10) Tempo de Segurança (1 segundo) 
....................           // (Carro e Pedestre ficam no vermelho) 
....................           delay_ms(1000); 
0272:  MOVLW  04
0273:  MOVWF  2B
0274:  MOVLW  FA
0275:  MOVWF  35
0276:  CALL   0A7
0277:  DECFSZ 2B,F
0278:  GOTO   274
....................           tempo += 1000; 
0279:  MOVLW  E8
027A:  ADDWF  21,F
027B:  MOVLW  03
027C:  BTFSC  03.0
027D:  MOVLW  04
027E:  ADDWF  22,F
....................            
....................           // 11) Retorna ao estado padrão (Carro Verde) 
....................           estado_padrao();  
027F:  CALL   091
....................            
....................           // A linha abaixo é redundante, pois estado_padrao() já faz isso, 
....................           // mas serve como reforço visual. 
....................           output_low(CARRO_VERMELHO); 
0280:  BSF    03.5
0281:  BCF    06.1
0282:  BCF    03.5
0283:  BCF    06.1
....................           output_high(CARRO_VERDE); 
0284:  BSF    03.5
0285:  BCF    06.3
0286:  BCF    03.5
0287:  BSF    06.3
....................        } 
....................         
....................        // 12. ATUALIZAÇÃO DO RELÓGIO MESTRE 
....................        // Esta é a "batida do coração" do sistema. 
....................        // O programa espera 50ms e atualiza o relógio 'tempo'. 
....................        // Isso garante que o 'tempo' continue contando mesmo quando 
....................        // o botão não está sendo pressionado. 
....................        delay_ms(50); 
0288:  MOVLW  32
0289:  MOVWF  35
028A:  CALL   0A7
....................        tempo += 50; 
028B:  MOVLW  32
028C:  ADDWF  21,F
028D:  BTFSC  03.0
028E:  INCF   22,F
028F:  GOTO   1AB
....................     } // Fim do while(TRUE) 
.................... } // Fim do main() 
0290:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
