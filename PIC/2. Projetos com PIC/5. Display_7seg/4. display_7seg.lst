CCS PCM C Compiler, Version 5.015, 5967               15-nov-25 18:07

               Filename:   C:\Users\Monitor\Desktop\MicroCon\Projetos PCW\4. display_7seg.lst

               ROM used:   141 words (2%)
                           Largest free fragment is 2048
               RAM used:   6 (2%) at main() level
                           12 (3%) worst case
               Stack used: 1 locations
               Stack size: 8

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   03B
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  3F
0009:  RETLW  06
000A:  RETLW  5B
000B:  RETLW  4F
000C:  RETLW  66
000D:  RETLW  6D
000E:  RETLW  7D
000F:  RETLW  07
0010:  RETLW  7F
0011:  RETLW  6F
0012:  MOVF   26,W
0013:  CLRF   78
0014:  SUBWF  25,W
0015:  BTFSC  03.0
0016:  GOTO   01A
0017:  MOVF   25,W
0018:  MOVWF  77
0019:  GOTO   026
001A:  CLRF   77
001B:  MOVLW  08
001C:  MOVWF  27
001D:  RLF    25,F
001E:  RLF    77,F
001F:  MOVF   26,W
0020:  SUBWF  77,W
0021:  BTFSC  03.0
0022:  MOVWF  77
0023:  RLF    78,F
0024:  DECFSZ 27,F
0025:  GOTO   01D
0026:  RETURN
....................  
.................... #list 
....................  
....................  
.................... // --- Configurações do Microcontrolador --- 
.................... #fuses NOWDT, NOBROWNOUT, NOLVP, HS // Fuses padrão para PICGenios 
.................... #use delay(crystal=20000000)      // Cristal de 20MHz 
0027:  MOVLW  25
0028:  MOVWF  04
0029:  BCF    03.7
002A:  MOVF   00,W
002B:  BTFSC  03.2
002C:  GOTO   03A
002D:  MOVLW  06
002E:  MOVWF  78
002F:  CLRF   77
0030:  DECFSZ 77,F
0031:  GOTO   030
0032:  DECFSZ 78,F
0033:  GOTO   02F
0034:  MOVLW  7B
0035:  MOVWF  77
0036:  DECFSZ 77,F
0037:  GOTO   036
0038:  DECFSZ 00,F
0039:  GOTO   02D
003A:  RETURN
....................  
.................... /* 
....................  * ================================================================= 
....................  * MAPEAMENTO DE HARDWARE (Placa PICGenios) 
....................  * ================================================================= 
....................  * Segmentos (a,b,c,d,e,f,g): PORTD (RD0 a RD6) 
....................  * 
....................  * Pinos de Controle dos Displays: 
....................  * DISP 1 (Milhar):  PIN_A2 
....................  * DISP 2 (Centena): PIN_A3 
....................  * DISP 3 (Dezena):  PIN_A4  <-- VAMOS USAR ESTE 
....................  * DISP 4 (Unidade): PIN_A5  <-- VAMOS USAR ESTE 
....................  */ 
....................   
.................... // Apelidos para os pinos que vamos usar 
.................... #define DISP_DEZENA   PIN_A4 // (DISP 3) 
.................... #define DISP_UNIDADE  PIN_A5 // (DISP 4) 
....................  
....................  
.................... // --- Mapa de Segmentos (Cátodo Comum) --- 
.................... // Define o padrão de bits em PORTD para formar cada número (0-9) 
.................... byte const display_map[10] = { 
....................    0b00111111, // 0 
....................    0b00000110, // 1 
....................    0b01011011, // 2 
....................    0b01001111, // 3 
....................    0b01100110, // 4 
....................    0b01101101, // 5 
....................    0b01111101, // 6 
....................    0b00000111, // 7 
....................    0b01111111, // 8 
....................    0b01101111  // 9 
.................... }; 
....................  
.................... // --- Função Principal --- 
.................... void main() { 
003B:  MOVF   03,W
003C:  ANDLW  1F
003D:  MOVWF  03
003E:  BSF    03.5
003F:  BSF    1F.0
0040:  BSF    1F.1
0041:  BSF    1F.2
0042:  BCF    1F.3
0043:  MOVLW  07
0044:  MOVWF  1C
0045:  BCF    03.7
....................  
....................     // --- Configuração Inicial (Setup) --- 
....................     set_tris_d(0x00); // Configura o PORTD (segmentos) como SAÍDA 
0046:  MOVLW  00
0047:  MOVWF  08
....................     set_tris_a(0x00); // Configura o PORTA (controle dos displays) como SAÍDA 
0048:  MOVWF  05
....................  
....................     // --- Variáveis do Programa --- 
....................     int8 contador = 0;   // Nosso contador, vai de 0 a 10 
....................     int8 dezena;         // Armazena o dígito da dezena 
....................     int8 unidade;        // Armazena o dígito da unidade 
....................     int i;               // Variável auxiliar para o loop de 1 segundo 
0049:  BCF    03.5
004A:  CLRF   21
....................      
....................     // --- Loop Infinito --- 
....................     while (TRUE) { 
....................          
....................         // 1. CALCULAR OS DÍGITOS 
....................         // Pega o número do contador e o quebra em dois dígitos 
....................         // Exemplo (contador = 10): 
....................         dezena = contador / 10;   // 10 / 10 = 1 
004B:  MOVF   21,W
004C:  MOVWF  25
004D:  MOVLW  0A
004E:  MOVWF  26
004F:  CALL   012
0050:  MOVF   78,W
0051:  MOVWF  22
....................         unidade = contador % 10;  // 10 % 10 = 0 (resto) 
0052:  MOVF   21,W
0053:  MOVWF  25
0054:  MOVLW  0A
0055:  MOVWF  26
0056:  CALL   012
0057:  MOVF   77,W
0058:  MOVWF  23
....................          
....................          
....................         // 2. MOSTRAR NO DISPLAY (Multiplexação por 1 segundo) 
....................         // Este loop 'for' é o nosso delay de 1 segundo. 
....................         // Ele roda 100 vezes, e em cada ciclo ele pisca 
....................         // a dezena e a unidade por 5ms cada (total 10ms). 
....................         // 100 ciclos * 10ms = 1000ms = 1 segundo. 
....................         for (i = 0; i < 100; i++) { 
0059:  CLRF   24
005A:  MOVF   24,W
005B:  SUBLW  63
005C:  BTFSS  03.0
005D:  GOTO   086
....................              
....................             // --- Acende o display da DEZENA (DISP 3) --- 
....................             output_high(DISP_DEZENA);       // Liga o pino RA4 
005E:  BSF    03.5
005F:  BCF    05.4
0060:  BCF    03.5
0061:  BSF    05.4
....................             output_d(display_map[dezena]);  // Envia o padrão do dígito (ex: '1') 
0062:  MOVF   22,W
0063:  CALL   004
0064:  MOVWF  25
0065:  BSF    03.5
0066:  CLRF   08
0067:  BCF    03.5
0068:  MOVF   25,W
0069:  MOVWF  08
....................             delay_ms(5);                    // Deixa aceso por 5ms 
006A:  MOVLW  05
006B:  MOVWF  25
006C:  CALL   027
....................             output_low(DISP_DEZENA);        // Apaga (evita "ghosting") 
006D:  BSF    03.5
006E:  BCF    05.4
006F:  BCF    03.5
0070:  BCF    05.4
....................              
....................             // --- Acende o display da UNIDADE (DISP 4) --- 
....................             output_high(DISP_UNIDADE);      // Liga o pino RA5 
0071:  BSF    03.5
0072:  BCF    05.5
0073:  BCF    03.5
0074:  BSF    05.5
....................             output_d(display_map[unidade]); // Envia o padrão do dígito (ex: '0') 
0075:  MOVF   23,W
0076:  CALL   004
0077:  MOVWF  25
0078:  BSF    03.5
0079:  CLRF   08
007A:  BCF    03.5
007B:  MOVF   25,W
007C:  MOVWF  08
....................             delay_ms(5);                    // Deixa aceso por 5ms 
007D:  MOVLW  05
007E:  MOVWF  25
007F:  CALL   027
....................             output_low(DISP_UNIDADE);       // Apaga 
0080:  BSF    03.5
0081:  BCF    05.5
0082:  BCF    03.5
0083:  BCF    05.5
0084:  INCF   24,F
0085:  GOTO   05A
....................         } 
....................          
....................         // 3. ATUALIZAR O CONTADOR 
....................         // Após 1 segundo mostrando o número, incrementa o contador 
....................         contador++; 
0086:  INCF   21,F
....................          
....................         // 4. VERIFICAR O LIMITE 
....................         // Se o contador passou de 10, reinicia em 0 
....................         if (contador > 10) { 
0087:  MOVF   21,W
0088:  SUBLW  0A
0089:  BTFSS  03.0
....................             contador = 0; 
008A:  CLRF   21
....................         } 
008B:  GOTO   04B
....................          
....................     } // Fim do while(TRUE), repete o ciclo com o novo número 
.................... } 
008C:  SLEEP

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
